### React 合成事件

分为 4 大块

* 对事件机制的初步理解和验证
* 对于合成的理解
* 事件注册机制
* 事件执行机制





#### 1、对事件机制的初步理解和验证

React 的所有事件没有绑定到具体的 dom 节点上，而是绑定在了 document 上；同时也是基于浏览器的事件机制（通过冒泡机制冒泡到最顶层元素），然后再由`dispatchEvent`统一去处理。

结论： 

* 原生事件阻止冒泡，肯定会阻止合成事件的触发；
* 合成事件的阻止冒泡不会影响原生事件；---> 原生事件优先执行；合成事件里面阻止冒泡只是阻止合成事件的冒泡

**回忆：**

浏览器事件机制：

> 浏览器的事件执行需要经过三个阶段： 
>
> 1、捕获阶段：事件从 window 对象自上而下向目标节点传播的阶段。
>
> 2、目标阶段：真正的目标节点，正在处理事件的阶段
>
> 3、冒泡阶段：事件从目标节点自下而上向 window 对象传播的阶段；

事件代理： 由于事件会在冒泡阶段向上传播子节点，因此可以把子节点的监听函数定义在父节点上，由父节点监听函数统一处理子元素的事件；addEventListener(事件名，fn ,默认 false （是否冒泡）)

* 优点：

> 1、减少内存消耗，提高性能
>
> 2、动态绑定事件

**回忆结束**



以上 我们知道了，节点上的原生事件的执行是在目标阶段，然而合成事件的执行是在冒泡阶段，所以

**原生事件会优先于合成事件执行 ** 然后在往父节点冒泡执行；

所以得出结论：

* 原生事件阻止冒泡，会阻止合成事件的执行；
* 合成事件阻止冒泡不会阻止原生事件的执行

#### 为什么要做这个合成事件？

意义？

* 减少内存消耗，提升性能，一种事件类型只在 document 上注册一次（原生的 DOM 事件，每个都去绑定事件，运行，是一件消耗很大的事情）；
* 统一规范，解决 IE 事件兼容问题，简化事件逻辑
* 对开发者友好

### 对于合成事件的理解

对于合成事件，其实 react 就做了一下几件事：

* 对原生事件的封装
* 对原生事件的升级和改造

> 比如： 在原生事件中的input 中的 onchange事件，在原生中，需要失去焦点的时候才能出发这个事件，而 React 则弥补了这个缺陷

* 浏览器事件的兼容

> 比如： 在处理事件委托的时候； 就判断了 浏览器的兼容问题；
>
> ```javascript
> 
> if(target.addEventListener) {
> 
> }else if (target.attchEvent) {// 区分 IE 
> 
> }
> ```



#### 事件注册的大致流程

首先进入组件挂载阶段，在 render()渲染--------> 调用 React.createElement(),得到 virtual Dom 树------------> 然后在dom 中拿到 Props,并判断里面是否有声明的事件，比如 onClick,等---------> 得到事件类型 click,change 和对应的事件处理函数，------> z在 document 上注册对应的事件类型 -------> 在将事件回调存储到 listenerBank 这个对象中； 到此就完成了 事件注册

#### 事件执行机制大致流程

1 、点击进入统一的事件分发函数（dispatchEvent）

2、结合原生事件找到当前节点对应的 ReactDOMComponent 对象

3、开始事件的合成

> * 根据当前事件类型生成指定的合成对象
> * 封装原生事件 和冒泡机制
> * 查找当前元素以及他所有的父级
> * 在 listenerBank 查找事件回调并合成到 event

4、批量处理合成事件内的回调事件

