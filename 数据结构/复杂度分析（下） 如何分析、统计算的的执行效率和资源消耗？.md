###复杂度分析（下） 浅析最好、最坏、平均、均摊时间复杂度？

上一节，我们讲了复杂度的大 O 表示法和几个分析技巧，还举了一些常见复杂度分析的例子，比如 O(1)、O(logn)、O(n)、O(nlogn) 复杂度分析。

本篇文章主要将从 4 个复杂度点去分析这方面的知识点：

* 最好情况复杂度（base case time complexity）：代码在最理想情况下执行的时间复杂度
* 最坏情况复杂度 (worst case time complexity)：代码在最坏情况下执行的时间复杂度
* 平均情况复杂度(average case time complexity)：用代码在所有情况下执行的次数的加权平均值表示
* 均摊时间复杂度(amortized time complexity)：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级 别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结 果就等于低级别复杂度

Ok, let's begin to learn the unknown ，Let's go;

####为什么要引入这4个概念?

1.同一段代码在不同情况下时间复杂度会出现量级差异，为了更加的全面，准确的描述代码的复杂度；

2. 代码复杂度在不同情况下出现量级差别的时候才需要区分这四种复杂度，大多数情况下是不需要分析他们的；



#### 难点？ 分析平均 和均摊时间复杂度？

> 1.平均时间复杂度 代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。 
>
> 2.均摊时间复杂度 两个条件满足时使用:
>
> ​	1.代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂 度;
>
> ​	2. 低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。



总结：时间复杂度的分析一般出现在有循环体的代码块中，难点在于该循环体的代码执行次数 依赖或者受某些条件的影响，正确分析这些条件是得出时间复杂度的前提。 如 递归算法，就需要考虑分析调用的次数，然后在看每次调用的耗时；

















自身学习记录；